# ----------------------------
# 924. Minimize Malware Spread
# ----------------------------

# Problem: https://leetcode.com/problems/minimize-malware-spread
#
# You are given a network of n nodes represented as an n x n adjacency matrix
# graph, where the ith node is directly connected to the jth node if graph[i][j]
# == 1.
# 
# Some nodes initial are initially infected by malware. Whenever two nodes are
# directly connected, and at least one of those two nodes is infected by malware,
# both nodes will be infected by malware. This spread of malware will continue
# until no more nodes can be infected in this manner.
# 
# Suppose M(initial) is the final number of nodes infected with malware in the
# entire network after the spread of malware stops. We will remove exactly one
# node from initial.
# 
# Return the node that, if removed, would minimize M(initial). If multiple nodes
# could be removed to minimize M(initial), return such a node with the smallest
# index.
# 
# Note that if a node was removed from the initial list of infected nodes, it
# might still be infected later due to the malware spread.
# 
# Example 1:
# 
# Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# Output: 0
# 
# Example 2:
# 
# Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
# Output: 0
# 
# Example 3:
# 
# Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
# Output: 1
# 
# 
# Constraints:
#         n == graph.length
#         n == graph[i].length
#         2 <= n <= 300
#         graph[i][j] is 0 or 1.
#         graph[i][j] == graph[j][i]
#         graph[i][i] == 1
#         1 <= initial.length <= n
#         0 <= initial[i] <= n - 1
#         All the integers in initial are unique.


# Solution: https://leetcode.com/problems/minimize-malware-spread/solutions/181186/python-dfs-solution-with-picture-to-explain-my-thought-with-extra-chinese-explanation 
# Credit: 王木流梦 -> https://leetcode.com/u/bupt_wc/
def min_malware_spread(graph, initial):
    def dfs(node,vis):
        for v in  range(len(graph[node])):
            if graph[node][v] == 1 and v not in vis:
                vis.add(v)
                dfs(v,vis)

    s = set(initial)
    t_vis = set()
    del_node, subgraph_len = min(initial), 0
    for node in range(len(graph)):
        if node not in t_vis:
            vis = set([node])
            dfs(node,vis)
            # caculate the number of infected node in the subgraph
            infect = vis & s
            if len(infect) == 1:
                # more number of nodes or smaller index
                if len(vis) > subgraph_len or (len(vis) == subgraph_len and list(infect)[0] < del_node):
                    del_node,subgraph_len = list(infect)[0],len(vis)
            t_vis |= vis
    return del_node
    # Time: O(n²)
    # Space: O(n)

# Alternative Solution: Using UnionFind
# Solution: https://algo.monster/liteproblems/924
# Credit: AlgoMonster


def main():
    result = min_malware_spread(graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1])
    print(result) # 0

    result = min_malware_spread(graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2])
    print(result) # 0

    result = min_malware_spread(graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2])
    print(result) # 1

if __name__ == "__main__":
    main()
